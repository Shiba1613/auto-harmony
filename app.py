# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eIJCgKKpQIzdLQKXLHtWS84wLIEXuvIb
"""

import streamlit as st
import librosa
import pyworld as pw
import numpy as np
import pysptk
import soundfile as sf
import io
import matplotlib.pyplot as plt

# ================================================
# ãƒ­ã‚¸ãƒƒã‚¯éƒ¨åˆ† (run_full_analysis, HarmoSynthesizer)
# ================================================

def run_full_analysis(x, fs, penta=0.5, precise_f0=False, key_original=True, W_triad=0.2, W_vi=0.5):
    """
    éŸ³å£°æ³¢å½¢ x ã‚’å—ã‘å–ã‚Šã€WORLDåˆ†æã¨ã‚­ãƒ¼åˆ¤å®šã‚’å®Ÿè¡Œã™ã‚‹ã€‚
    """
    # --- 1. WORLDåˆ†æ ---
    try:
        x = x.astype(np.float64) # PyWorldç”¨ã«float64ã«å¤‰æ›
        if precise_f0:
            f0, t = pw.harvest(x, fs)
        else:
            f0, t = pw.dio(x, fs)
            f0 = pw.stonemask(x, f0, t, fs)

        sp = pw.cheaptrick(x, f0, t, fs)
        ap = pw.d4c(x, f0, t, fs)
        f0 = f0 * (ap[:,0] < 0.5) # ç„¡éŸ³åŒºé–“ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°

    except Exception as e:
        st.error(f"åˆ†æã‚¨ãƒ©ãƒ¼: {e}")
        return None, None, None, None, None, None

    # --- 2. ã‚­ãƒ¼åˆ†æãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã®å®šç¾© ---
    # KSæ³•ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ« (Cãƒã‚¤ãƒŠãƒ¼é¢¨ - å…ƒã‚³ãƒ¼ãƒ‰æº–æ‹ )
    C_ks = np.array([1, 0, penta, 1, 0, 1, 0, 1, penta, 0, 1, 0])
    key_mat_KS = np.stack([np.roll(C_ks, i) for i in range(12)])

    # ãƒˆãƒ‹ãƒƒã‚¯ãƒ»ãƒˆãƒ©ã‚¤ã‚¢ãƒ‰(ä¸»å’ŒéŸ³)ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«
    C_triad = np.array([1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0])
    matrix_Triad = np.stack([np.roll(C_triad, i) for i in range(12)])

    # éŸ³å(N)ã®è¨ˆç®—
    f0_for_calc = f0.copy()
    f0_for_calc[f0 == 0] = 1e-10
    N = ((np.log2(f0_for_calc) - np.log2(440) + 1/24)*12//1%12).astype(np.int8)

    # --- 3. ã‚¹ã‚³ã‚¢è¨ˆç®— (ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ) ---
    v = np.array([])
    f0_voiced = f0[f0 != 0]
    if len(f0_voiced) == 0:
        return None, None, None, None, None, None

    if key_original:
        normed_f0 = (np.log2(f0_voiced) - np.log2(440) + 1/24) % 1
        v = np.histogram(normed_f0, bins=12, range=(0, 1))[0]
    else:
        def f02tone(f0):
            return (np.log2(f0+1e-10) - np.log2(440) + 1/24)*12//1
        def longtone_hist(f0):
            N = f02tone(f0)
            x_ = f0[1:] * ((N[1:] -  N[:-1]) != 0.)* (ap[1:,0] < 0.5)
            tone = (f02tone(x_[x_!=0]))%12
            return np.histogram(tone,bins=12,range=(0,11))[0]
        v = longtone_hist(f0)
        
    # ã€Œè¢‹è©°ã‚ã€ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—
    scores_KS = key_mat_KS @ v
    scores_Triad = matrix_Triad @ v
    final_scores = scores_KS + (W_triad * scores_Triad)

    # --- 4. ã‚¹ã‚³ã‚¢è¨ˆç®— (V-Iãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³) ---
    vi_scores = np.zeros(12)
    note_changes_idx = np.where(N[1:] != N[:-1])[0] + 1

    for idx in note_changes_idx:
        N_prev = N[idx - 1]
        N_curr = N[idx]

        if f0[idx-1] == 0 or f0[idx] == 0:
            continue

        for key_idx in range(12):
            tonic_note = key_idx
            dominant_note = (key_idx + 7) % 12

            if N_prev == dominant_note and N_curr == tonic_note:
                vi_scores[key_idx] += 1

    # æœ€çµ‚ã‚¹ã‚³ã‚¢ã«ã€V-Iã‚¹ã‚³ã‚¢ã‚’é‡ã¿ä»˜ã‘ã—ã¦åŠ ç®—
    final_scores = final_scores + (W_vi * vi_scores)

    # --- 5. çµæœã®è¿”å´ ---
    best_index = np.argmax(final_scores)

    return x, f0, sp, ap, best_index, N, final_scores


class HarmoSynthesizer:
    def __init__(self, sr=48000, shift_up=True, warp_coeff=0.0, num_coeff=64, window_len=5,smooth_FM = False):
        self.sr = sr
        self.frame_period = 5
        self.fftlen = pw.get_cheaptrick_fft_size(self.sr)
        self.num_coeff = num_coeff

        if shift_up:
            self.pitch_shift = 2 ** (np.array([3,4,3,4,3,3,4,3,4,3,4,3])/12)
        else:
            self.pitch_shift = 2 **(-np.array([4,3,4,3,4,3,3,4,3,4,3,3])/12)

        self.warp_in = pysptk.util.mcepalpha(self.sr)
        self.warp_out = self.warp_in + warp_coeff
        self.use_warp = (self.warp_in != self.warp_out)

        if window_len > 1:
            window = np.hanning(window_len)
            self.window = window / np.sum(window)
        else:
            self.window = None
        self.smooth_FM = smooth_FM

    def pitch_coeff(self, f0, N, idx):
        v_ = np.roll(self.pitch_shift, -idx)
        f0_shifted = f0 * v_[N]
        if self.window is not None:
            if self.smooth_FM:
                f0_shifted = f0 * np.convolve(v_[N], self.window, 'same')
            else:
                f0_shifted = np.convolve(f0, self.window, 'same')
        return f0_shifted

    def freq_warp(self, sp):
        mc = pysptk.sp2mc(sp, self.num_coeff, self.warp_in)
        return pysptk.mc2sp(mc, self.warp_out, self.fftlen)

    def synth(self, f0, sp, ap, N, key_index):
        f0_ = self.pitch_coeff(f0, N, key_index)

        if self.use_warp:
            sp_ = self.freq_warp(sp)
        else:
            sp_ = sp

        # ãƒã‚¤ã‚ºå¯¾ç­–: apã®ãƒ¯ãƒ¼ãƒ—ã¯è¡Œã‚ãšã€å…ƒã®apã‚’ä½¿ç”¨
        ap_ = ap

        y = pw.synthesize(f0_, sp_, ap_, self.sr, self.frame_period)
        return y

# ================================================
# Streamlit UI éƒ¨åˆ†
# ================================================

st.title("ğŸµ è‡ªå‹•ãƒãƒ¢ãƒªç”Ÿæˆã‚¢ãƒ—ãƒª")
st.write("ãƒœãƒ¼ã‚«ãƒ«éŸ³æº(wav)ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã¨ã€ã‚­ãƒ¼ã‚’æ¨å®šã—ã¦ãƒãƒ¢ãƒªãƒ‘ãƒ¼ãƒˆã‚’ç”Ÿæˆã—ã¾ã™ã€‚")

# ã‚µã‚¤ãƒ‰ãƒãƒ¼è¨­å®š
st.sidebar.header("è¨­å®š")
key_original = st.sidebar.checkbox("å›ºå®šé•·åˆ†å‰²", value=True)
smooth_FM = st.sidebar.checkbox("ã‚·ãƒ•ãƒˆå¹³æ»‘åŒ–(ã¾ãŸã¯ãƒ”ãƒƒãƒå¹³æ»‘åŒ–)", value=False)
precise_f0 = st.sidebar.checkbox("æ­£ç¢ºãªf0", value=False)
# ä¸Šãƒãƒ¢ãƒª or ä¸‹ãƒãƒ¢ãƒª
harmo_mode = st.sidebar.radio(
    "ãƒãƒ¢ãƒªã®ç¨®é¡",
    ("ä¸Šãƒãƒ¢ãƒª (3åº¦ä¸Š)", "ä¸‹ãƒãƒ¢ãƒª (3åº¦ä¸‹)"),
    horizontal=False
)

shift_up = (harmo_mode == "ä¸Šãƒãƒ¢ãƒª (3åº¦ä¸Š)")

penta_weight = st.sidebar.slider("ãƒšãƒ³ã‚¿ãƒˆãƒ‹ãƒƒã‚¯é‡ã¿ (PENTA)", 0.0, 1.0, 0.5)
amp = st.sidebar.slider("ãƒãƒ¢ãƒªéŸ³é‡ (AMP)", 0.0, 1.0, 0.5)

st.sidebar.subheader("è©³ç´°è¨­å®š")
w_triad = st.sidebar.slider("ãƒˆãƒ©ã‚¤ã‚¢ãƒ‰é‡ã¿ (W_TRIAD)", 0.0, 1.0, 0.2)
w_vi = st.sidebar.slider("V-Ié€²è¡Œé‡ã¿ (W_VI)", 0.0, 1.0, 0.5)
warp_coeff = st.sidebar.slider("å£°è³ªå¤‰æ› (WARP)", -0.2, 0.2, 0.0)

uploaded_file = st.file_uploader("WAVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰", type=["wav"])

if uploaded_file is not None:
    st.audio(uploaded_file, format='audio/wav')

    if st.button("ãƒãƒ¢ãƒªç”Ÿæˆé–‹å§‹"):
        with st.spinner("åˆ†æãƒ»ç”Ÿæˆä¸­... (æ•°ç§’ã€œæ•°åç§’ã‹ã‹ã‚Šã¾ã™)"):
            # 1. ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
            # Streamlitã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã¯ç›´æ¥librosaã§èª­ã‚ã‚‹ãŒã€srã‚’æŒ‡å®šã™ã‚‹
            x, sr = librosa.load(uploaded_file, sr=48000, dtype=np.float64)

            # 2. åˆ†æå®Ÿè¡Œ
            x, f0, sp, ap, detected_key, N, scores = run_full_analysis(
                x, sr,
                penta=penta_weight,
                precise_f0=precise_f0, # é«˜é€ŸåŒ–ã®ãŸã‚Dioå›ºå®š
                key_original=key_original,
                W_triad=w_triad,
                W_vi=w_vi
            )

            if detected_key is not None:
                key_names_en = ["C", "Db", "D", "Eb", "E", "F", "F#", "G", "Ab", "A", "Bb", "B"]
                key_name = key_names_en[detected_key]
                st.success(f"æ¨å®šã•ã‚ŒãŸã‚­ãƒ¼: **{key_name}**")

                # ã‚¹ã‚³ã‚¢ã‚°ãƒ©ãƒ•ã®è¡¨ç¤º
                fig, ax = plt.subplots(figsize=(10, 4))
                ax.bar(key_names_en, scores, color='blue')
                ax.bar(key_names_en[detected_key], scores[detected_key], color='red')
                ax.set_title("Key Estimation Scores")
                st.pyplot(fig)

                # 3. ãƒãƒ¢ãƒªåˆæˆ
                harmo = HarmoSynthesizer(
                    sr=sr,
                    shift_up=shift_up,
                    warp_coeff=warp_coeff,
                    smooth_FM = smooth_FM
                )
                y_hamori = harmo.synth(f0, sp, ap, N, detected_key)

                # 4. ãƒŸãƒƒã‚¯ã‚¹
                len_min = min(len(x), len(y_hamori))
                y_mixed = x[:len_min] + amp * y_hamori[:len_min]

                # æ­£è¦åŒ–
                max_val = np.max(np.abs(y_mixed))
                if max_val > 1.0:
                    y_mixed = y_mixed / max_val

                # 5. çµæœè¡¨ç¤º
                st.subheader("ç”Ÿæˆçµæœ")

                # WAVãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦æ›¸ãå‡ºã— (ãƒ¡ãƒ¢ãƒªä¸Š)
                buffer = io.BytesIO()
                sf.write(buffer, y_mixed, sr, format='WAV')
                buffer.seek(0)

                st.audio(buffer, format='audio/wav')

                st.download_button(
                    label="ãƒãƒ¢ãƒªä»˜ãéŸ³æºã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰",
                    data=buffer,
                    file_name="hamori_mixed.wav",
                    mime="audio/wav"
                )
                                
                buffer = io.BytesIO()
                sf.write(buffer, y_hamori[:len_min], sr, format='WAV')
                buffer.seek(0)

                st.audio(buffer, format='audio/wav')

                st.download_button(
                    label="ãƒãƒ¢ãƒªã®ã¿éŸ³æºã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰",
                    data=buffer,
                    file_name="hamori_only.wav",
                    mime="audio/wav"
                )
                
            else:
                st.error("åˆ†æã«å¤±æ•—ã—ã¾ã—ãŸã€‚éŸ³å£°ãŒå«ã¾ã‚Œã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚")
